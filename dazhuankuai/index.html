<!DOCTYPE html>
<html lang="en">
<head>
    <!--适配-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta name="viewport" content="width=device-width,minimum-scale=1,user-scalable=no,maximum-scale=1,initial-scale=1">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<meta name="format-detection" content="telephone=no">  
	<meta http-equiv="x-rim-auto-match" content="none">  
    <!--适配-->
    <title>打砖块DEMO</title>
    <!--距离关节就是指刚体中点之间的距离不变-->
    <style>
            *,
        ::before,
        ::after {
        padding: 0;
        margin: 0;
        -webkit-tap-highlight-color: transparent;
        -webkit-box-sizing: border-box;
        box-sizing: border-box; }

        #dazhuankuai_game {
            width: 16rem !important;
            margin: 0 auto;}

        #dazhuankuai_game canvas {
            width: 16rem !important;
            margin: 0 auto;}

    </style>
</head>
<!--加上font-size:0;解决1.9.7白底边bug-->
<body style="font-size:0;">
    <div id="dazhuankuai_game"></div>
    <script src="./js/jquery.js"></script>
    <script src="./js/Box2dWeb-2.1.a.3.min.js"></script>
    <script src="./js/lufylegend-1.10.1.js"></script>
    <script>
    ;(function (doc, win) {
        var docEl = doc.documentElement,
        resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
                recalc = function () {
            var clientWidth = docEl.clientWidth;
            if (!clientWidth) return;
            if(clientWidth > 800) clientWidth=800;
            docEl.style.fontSize = 20 * (clientWidth / 320) + 'px';
        };
        
        if (!doc.addEventListener) return;
        win.addEventListener(resizeEvt, recalc, false);
        recalc();
    })(document, window);
        
    ;(function(){
        // 问题： setBodyMouseJoint失效
        // 全局配置G
        var G = {
            // 游戏状态(1:游戏开始时2:球已经发射)
            "globalState": 1,
            // canvas ID
            "canvasId":"dazhuankuai_game",
            // 画布宽
            "GAME_WIDTH": 640,
            // 画布高
            "GAME_HEIGHT": 640*window.innerHeight/window.innerWidth,
            // 背景层
            "backLayer": null,
            // 加载层
            "loadingLayer": null,
            // 舞台层
            "stageLayer": null,
            // 图片缓存
            "imglist": {},
            // 地板刚体
            "floor": null,
            // 发射区域圆心
            "point": {x:320,y:640*window.innerHeight/window.innerWidth-120-15},
            // 小球
            "ball": null,
            // 点击的初始位置
            "STARTX": 0,
            // 位移
            "distance": 0,
            // 倒计时文字
            "field": null,
            // 开启距离计算
            "flag": false ,
            // 保存球的位置的数组
            "posiArr": [],
            // 重弹标志
            "reflag": false,
            // 来球方向标志(false:右方true:左方)
            "direflag": false,
            // 光圈
            "halo": null,
            // 光圈缓动播完标志
            "overflag": true,
            // 方块被撞击次数
            "num": 0
        }
        var imgData = new Array({
            name: "bg2",
            path: "./images/bg2.jpg"
        },{
            name: "top",
            path: "./images/top.png"
        },{
            name: "wall",
            path: "./images/juxing.png"
        },{
            name: "sprite",
            path: "./images/sprite.png"
        });
        
        LInit(10, G.canvasId , G.GAME_WIDTH, G.GAME_HEIGHT, start);

        // 进程
        function start(){
            LGlobal.setDebug(true);
            
            // 实现移动端适配，1.6以后才能使用这个API
            LGlobal.align = LStageAlign.TOP_LEFT;
            LGlobal.stageScale = LStageScaleMode.SHOW_ALL;
            LSystem.screen(LStage.FULL_SCREEN);
            G.backLayer = new LSprite();
            addChild(G.backLayer);
            //利用LLoadManage读取图片, 显示进度条, 执行init
            G.loadingLayer = new LoadingSample5(12);
            G.backLayer.addChild(G.loadingLayer);
            G.backLayer.removeAllChild(G.loadingLayer);
            LLoadManage.load(
                imgData,
                function(progress) {
                    G.loadingLayer.setProgress(progress);
                },
                // 不能写init,冲突
                initGame
            );  
        }

        function initGame(result) {
            //取得图片读取结果
            G.imglist = result;
            //移除进度条
            G.backLayer.removeAllChild(G.loadingLayer);
            G.loadingLayer = null;
            //游戏逻辑
            main();
        }

        function main() {
            // 格式化背景层
            G.backLayer.die();
            G.backLayer.removeAllChild();
            // 加载游戏背景实例
            bgo = new Background(); 
            G.backLayer.addChild(bgo);
            // 初始化Box2dweb 
            LGlobal.box2d = new LBox2d();

            // 舞台初始化
            stageInit();   
            // 添加头部实例
            var top = new Top();
            top.x = 320;
            top.y = 62.5;
            G.stageLayer.addChild(top);
            top.addBodyPolygon(640,125,0,10,0.4,0);

            // 通过顶点坐标加入2面墙
            var wall1 = new Wall();
            wall1.x = 11;
            wall1.y = G.GAME_HEIGHT/2;
            G.stageLayer.addChild(wall1);
            wall1.addBodyPolygon(22,G.GAME_HEIGHT,0,10,0.4,0);

            var wall2 = new Wall();
            wall2.x = 640-11;
            wall2.y = G.GAME_HEIGHT/2;
            G.stageLayer.addChild(wall2);
            wall2.addBodyPolygon(22,G.GAME_HEIGHT,0,10,0.4,0);
            // 设置层级,最底下调到最上面
            G.stageLayer.setChildIndex(G.stageLayer.getChildAt(0), G.stageLayer.numChildren-1);

            // 设置底部的地板
            G.floor = new Floor();
            G.floor.x = 320;
            G.floor.y = G.GAME_HEIGHT-120+8;
            G.stageLayer.addChild(G.floor);
            G.floor.addBodyPolygon(130,16,0,1,0.9,2);
            // 添加移动
            G.floor.addEventListener(LMouseEvent.MOUSE_DOWN, onmousedown);
            G.backLayer.addEventListener(LMouseEvent.MOUSE_MOVE, onmousemove);
            G.backLayer.addEventListener(LMouseEvent.MOUSE_UP, onmouseup);

            // 小球
            G.ball = new Ball();
            G.ball.x = G.point.x;
            G.ball.y = G.point.y;
            G.stageLayer.addChild(G.ball);
            G.ball.addBodyCircle(15,0,0,1,0.1,0.9,0.1);
            // 倒计时3s,随机发射
            G.field = new LTextField();
            G.backLayer.addChild(G.field);
            doTimeDown(3);
            // 加入碰撞侦听事件
            LGlobal.box2d.setEvent(LEvent.POST_SOLVE,postSolve);
            
            // 方块
            var box1 = new Box();
            box1.getHardBox(box1.box1,22,188,G.imglist["sprite"],[23,157,52,48]);
            var box2 = new Box();
            box2.getHardBox(box2.box2,22,430,G.imglist["sprite"],[23,157,52,48]);
            var box3 = new Box();
            box3.getHardBox(box3.box3,410,188,G.imglist["sprite"],[23,157,52,48]);
            var box4 = new Box();
            box4.getHardBox(box4.box4,410,430,G.imglist["sprite"],[23,157,52,48]);
            var box5 = new Box();
            box5.getBox(box5.box5,164,263,G.imglist["sprite"],[131,157,52,48]);

            // 循环动画
            G.backLayer.addEventListener(LEvent.ENTER_FRAME, onframe);
        }
        // 跟踪
        function onframe() {
            switch(G.globalState){
                // 跟踪小球坐标
                case 2:
                    if(G.posiArr.length<30) {
                        G.posiArr.push({"x":G.ball.x,"y":G.ball.y});
                    }else {
                        G.posiArr.shift();
                        G.posiArr.push({"x":G.ball.x,"y":G.ball.y});
                    }
                    // 左方
                    if( G.posiArr.length==30 &&　G.posiArr[0].x < G.posiArr[29].x ) {
                        G.direflag = true;
                        console.log(0); 
                    }else if( G.posiArr.length==30　&&　G.posiArr[0].x >= G.posiArr[29].x ) {
                        G.direflag = false;
                        console.log(1);
                    }
                    break;
                case 3:
                    breack;
                default:
           } 
        //    if(G.posiArr.length==30 
        //        && (Math.abs( parseInt(G.posiArr[0].x) - parseInt(G.posiArr[14].x ))< 130) 
        //        && (G.globalState==2) 
        //        && ( Math.abs(parseInt(G.posiArr[14].x) - parseInt(G.posiArr[29].x))<130 )){
        //        console.log("原地重弹");
        //        G.reflag = true;
        //    }
        }
        // 碰撞(问题：无法给动态的刚体添加力,可能是要清除所有力，再添加力；但是添加冲量的效果很明显)
        function postSolve(contact,impulse) {
            var objA = contact.GetFixtureA().GetBody().GetUserData();
            var objB = contact.GetFixtureB().GetBody().GetUserData();

            if(objA.name == "ball" && (objB.name == "box" || objB.name == "hardBox") ){
                // 处理打两次才消除的方块
                if(objB.name == "box"){
                    G.stageLayer.removeChild(objB);
                }else if( objB.name == "hardBox" && objB.num == 0){
                    objB.num++;
                    objB.alpha = 0.5;
                }else {
                    G.stageLayer.removeChild(objB);
                }
                // 撞击的缓动动画
                if(G.overflag){
                    G.halo = new Halo();
                    G.halo.x = objB.x;
                    G.halo.y = objB.y;
                    G.halo.scaleX = 0.5;
                    G.halo.scaleY = 0.5;
                    G.stageLayer.addChild(G.halo);
                    G.overflag = false;
                }
                LTweenLite.to(G.halo,0.05,{scaleX:1,scaleY:1,onComplete:function(){
                    G.stageLayer.removeChild(G.halo);
                    G.overflag = true;
                }});

            }else if((objA.name == "box" || objA.name == "hardBox") && objB.name == "ball"){
                // 处理打两次才消除的方块
                if(objA.name == "box"){
                    G.stageLayer.removeChild(objA);
                }else if( objA.name == "hardBox" && objA.num == 0){
                    objA.num++;
                    objA.alpha = 0.5;
                }else {
                    G.stageLayer.removeChild(objA);
                }
                // 撞击的缓动动画
                if(G.overflag){
                    G.halo = new Halo();
                    G.halo.x = objB.x;
                    G.halo.y = objB.y;
                    G.halo.scaleX = 0.5;
                    G.halo.scaleY = 0.5;
                    G.stageLayer.addChild(G.halo);
                    G.overflag = false;
                }
                LTweenLite.to(G.halo,0.1,{scaleX:1,scaleY:1,onComplete:function(){
                    G.stageLayer.removeChild(G.halo);
                    G.overflag = true;
                }});

            }else if(objA.name == "ball" && objB.name == "floor" && G.globalState==2) {
                
            }else if(objA.name == "floor" && objB.name == "ball" && G.globalState==2){
                // 重弹处理
                // var arrRight = [-1*Math.PI/12,-2*Math.PI/12,-3*Math.PI/12];
                // var arrLeft = [-11*Math.PI/12,-10*Math.PI/12,-9*Math.PI/12];
                // if(G.reflag){
                //     var arr = [-1*Math.PI/12,-2*Math.PI/12,-3*Math.PI/12,-11*Math.PI/12,-10*Math.PI/12,-9*Math.PI/12];
                //     var angle = arr[parseInt(Math.random()*6)];
                //     var force = 0.5;
                //     var vec = new LGlobal.box2d.b2Vec2(force*Math.cos(angle),force*Math.sin(angle)); // 施加固定角度的力
                //     // G.ball.box2dBody.ApplyForce(vec,G.ball.box2dBody.GetWorldCenter()); // 失效
                //     G.ball.box2dBody.ApplyImpulse(vec, G.ball.box2dBody.GetWorldCenter()) // 冲量
                //     G.reflag = false;
                // }
                // 随机角度处理
                if(G.direflag){
                     var angle = 0;
                }else {
                    var angle = -Math.PI;
                }
                var force = 0.8;
                var vec = new LGlobal.box2d.b2Vec2(force*Math.cos(angle),force*Math.sin(angle)); // 施加固定角度的力
                // G.ball.box2dBody.ApplyForce(vec,G.ball.box2dBody.GetWorldCenter()); // 失效
                G.ball.box2dBody.ApplyImpulse(vec, G.ball.box2dBody.GetWorldCenter()) // 冲量
            }
        }
        // 动画(鼠标按下，移动，抬起)
        function onmousedown(event) {
            G.flag = true;
        }
        function onmousemove(event) {
            /**
            * 使用SetPosition设定刚体位置的时候，参数也是box2d世界中的单位。
            * 而box2d世界中的单位和像素值之间的换算单位是LGlobal.box2d.drawScale，也就是
            * 像素坐标＝box2d中的坐标/LGlobal.box2d.drawScale；
            * 当然，重新设定了坐标之后，要唤醒刚体
            */
            if(G.flag){
                if(event.offsetX>=87 && event.offsetX<=553){
                    G.floor.box2dBody.SetPosition(new LGlobal.box2d.b2Vec2(event.offsetX/LGlobal.box2d.drawScale,G.floor.box2dBody.GetPosition().y));
                    if(G.globalState==1){
                        G.ball.box2dBody.SetPosition(new LGlobal.box2d.b2Vec2(event.offsetX/LGlobal.box2d.drawScale,G.ball.box2dBody.GetPosition().y));
                    }
                }
                G.floor.box2dBody.SetAwake(true);
            }
        }
        function onmouseup(event) {
             G.flag = false;
        }
        // Tools fn
        // 写时间
        function writeTime(time) {
            G.field.text = time;
            G.field.x = 288;
            G.field.y = 330;
            G.field.size = 100;
            G.field.color = "#333";
            G.field.weight = "bolder";
            // G.stageLayer.graphics.drawRect(2, "#ff0000", [ G.stageLayer.x-14,  G.stageLayer.y,  G.stageLayer.getWidth(),  G.stageLayer.getHeight()], true, "#880088");
        }
        // 随机角度发射
        function shoot(flag) {
            if(flag){
                // var angle = (parseInt(Math.random()*90)+60)*(180/Math.PI)*(Math.random>0.5?1:-1);
                var arr = [-5*Math.PI/12,-7*Math.PI/12];
                var angle = arr[parseInt(Math.random()*2)];
                var force = 50;
                var vec = new LGlobal.box2d.b2Vec2(force*Math.cos(angle),force*Math.sin(angle));
                G.ball.box2dBody.ApplyForce(vec,G.ball.box2dBody.GetWorldCenter());
            }
        }
        // 倒计时
        function doTimeDown(time){
            var timer = setInterval(function(){
                if(time > 0){
                    if(writeTime && typeof writeTime == "function"){
                        writeTime(time);
                        time--;
                    }
                }else{
                    if(shoot && typeof shoot == "function"){
                        G.backLayer.removeChild(G.field);
                        clearInterval(timer);
                        shoot(true);
                        G.globalState=2;
                    }
                }
            },1000);
        }
        // 背景层，舞台层，顶层，地板层，小球层，光圈层，方块层(创建方块刚体)
        function Background() {
            base(this, LSprite, []);
            var self = this;
            self.bitmapData = new LBitmapData(G.imglist["bg2"],0,0,640,1030);
            self.bitmap = new LBitmap(self.bitmapData);
            var sy = G.GAME_HEIGHT/self.bitmapData.height;// 缩放，将背景图拉伸至全屏
            self.bitmap.scaleY = sy;
            self.addChild(self.bitmap);
        }
        function stageInit() {
            G.stageLayer = new LSprite();
            G.backLayer.addChild(G.stageLayer);
        } 
        function Top() {
            base(this, LSprite, []);
            var self = this;
            self.bitmapData = new LBitmapData(G.imglist["top"],0,0,640,133);
            self.bitmap = new LBitmap(self.bitmapData);
            self.addChild(self.bitmap);
        }
        function Wall() {
            base(this, LSprite, []);
            var self = this;
            self.bitmapData = new LBitmapData(G.imglist["wall"],0,0,22,1006);
            self.bitmap = new LBitmap(self.bitmapData);
            var sy = G.GAME_HEIGHT/self.bitmapData.height;// 缩放，将背景图拉伸至全屏
            self.bitmap.scaleY = sy;
            self.addChild(self.bitmap);
        }
        function Floor() {
            base(this, LSprite, []);
            var self = this;
            self.name = "floor";
            self.bitmapData = new LBitmapData(G.imglist["sprite"],537,166,130,16);
            self.bitmap = new LBitmap(self.bitmapData);
            self.addChild(self.bitmap);
        }
        function Ball() {
            base(this, LSprite, []);
            var self = this;
            self.name = "ball";
            self.bitmapData = new LBitmapData(G.imglist["sprite"],359,158,30,29);
            self.bitmap = new LBitmap(self.bitmapData);
            self.addChild(self.bitmap); 
        }
        function Halo() {
            base(this, LSprite, []);
            var self = this;
            self.name = "halo";
            self.bitmapData = new LBitmapData(G.imglist["sprite"],204,259,70,68);
            self.bitmap = new LBitmap(self.bitmapData);
            self.bitmap.x = -self.bitmap.getWidth()*0.5;
            self.bitmap.y = -self.bitmap.getHeight()*0.5;
            self.addChild(self.bitmap); 
        }
        function Box() {
            var self = this;
            self.box1 = [[1,1,1,1],
                         [1,1,1,0],
                         [1,1,0,0],
                         [1,0,0,0]];
            self.box2 = [[1,0,0,0],
                         [1,1,0,0],
                         [1,1,1,0],
                         [1,1,1,1]];
            self.box3 = [[1,1,1,1],
                         [0,1,1,1],
                         [0,0,1,1],
                         [0,0,0,1]];
            self.box4 = [[0,0,0,1],
                         [0,0,1,1],
                         [0,1,1,1],
                         [1,1,1,1]];
            self.box5 = [[0,0,1,1,0,0],
                         [0,1,1,1,1,0],
                         [1,1,1,1,1,1],
                         [1,1,1,1,1,1],
                         [0,1,1,1,1,0],
                         [0,0,1,1,0,0]];
        }
        Box.prototype = {
            getBox : function(box,START_X,START_Y,imgObj,arr) {
                var i,j,bitmap;
	            for(i=0;i<box.length;i++){
                    for(j=0;j<box[0].length;j++){
                        if(box[i][j] == 0){
                            continue;
                        }
                        var sprite = new LSprite();
                        sprite.name = "box";
                        var bitmapData = new LBitmapData(G.imglist["sprite"],arr[0],arr[1],arr[2],arr[3]);
                        var bitmap = new LBitmap(bitmapData);
                        sprite.addChild(bitmap);

                        sprite.x = (bitmap.getWidth()*j+START_X) + (bitmap.getWidth()/2);
                        sprite.y = (bitmap.getHeight()*i+START_Y) + (bitmap.getHeight()/2);
                        G.stageLayer.addChild(sprite);
                        sprite.addBodyPolygon(bitmap.getWidth(),bitmap.getHeight(),0,5,0.4,0);
                    }
                }
            },
            getHardBox : function(box,START_X,START_Y,imgObj,arr) {
                var i,j,bitmap;
	            for(i=0;i<box.length;i++){
                    for(j=0;j<box[0].length;j++){
                        if(box[i][j] == 0){
                            continue;
                        }
                        var sprite = new LSprite();
                        sprite.name = "hardBox";
                        sprite.num = 0;
                        var bitmapData = new LBitmapData(G.imglist["sprite"],arr[0],arr[1],arr[2],arr[3]);
                        var bitmap = new LBitmap(bitmapData);
                        sprite.addChild(bitmap);

                        sprite.x = (bitmap.getWidth()*j+START_X) + (bitmap.getWidth()/2);
                        sprite.y = (bitmap.getHeight()*i+START_Y) + (bitmap.getHeight()/2);
                        G.stageLayer.addChild(sprite);
                        sprite.addBodyPolygon(bitmap.getWidth(),bitmap.getHeight(),0,5,0.4,0);
                    }
                }
            }
        }
    })();
    </script>
</body>
</html>